import {
  DEFINE_OPTIONS_NAME
} from "./chunk-J7XFY43W.mjs";

// src/core/utils.ts
import { parse, walkIdentifiers } from "@vue/compiler-sfc";
function isCallOf(node, test) {
  return !!(node && node.type === "CallExpression" && node.callee.type === "Identifier" && (typeof test === "string" ? node.callee.name === test : test(node.callee.name)));
}
var parseSFC = (code, id) => {
  const { descriptor } = parse(code, {
    filename: id
  });
  return descriptor;
};
var filterMarco = (scriptSetup) => {
  return scriptSetup.scriptSetupAst.map((raw) => {
    let node = raw;
    if (raw.type === "ExpressionStatement")
      node = raw.expression;
    return isCallOf(node, DEFINE_OPTIONS_NAME) ? node : void 0;
  }).filter((node) => !!node);
};
function checkInvalidScopeReference(node, method, scriptSetup) {
  if (!node)
    return;
  walkIdentifiers(node, (id) => {
    if (Object.keys(scriptSetup.bindings).includes(id.name) && !Object.keys(scriptSetup.imports).includes(id.name))
      throw new SyntaxError(`\`${method}()\` in <script setup> cannot reference locally declared variables because it will be hoisted outside of the setup() function.`);
  });
}
var hasPropsOrEmits = (node) => node.properties.some((prop) => (prop.type === "ObjectProperty" || prop.type === "ObjectMethod") && prop.key.type === "Identifier" && (prop.key.name === "props" || prop.key.name === "emits"));

export {
  isCallOf,
  parseSFC,
  filterMarco,
  checkInvalidScopeReference,
  hasPropsOrEmits
};

"use strict";Object.defineProperty(exports, "__esModule", {value: true});

var _chunk4DY6RZ4Jjs = require('./chunk-4DY6RZ4J.js');

// src/core/utils.ts
var _compilersfc = require('@vue/compiler-sfc');
function isCallOf(node, test) {
  return !!(node && node.type === "CallExpression" && node.callee.type === "Identifier" && (typeof test === "string" ? node.callee.name === test : test(node.callee.name)));
}
var parseSFC = (code, id) => {
  const { descriptor } = _compilersfc.parse.call(void 0, code, {
    filename: id
  });
  return descriptor;
};
var filterMarco = (scriptSetup) => {
  return scriptSetup.scriptSetupAst.map((raw) => {
    let node = raw;
    if (raw.type === "ExpressionStatement")
      node = raw.expression;
    return isCallOf(node, _chunk4DY6RZ4Jjs.DEFINE_OPTIONS_NAME) ? node : void 0;
  }).filter((node) => !!node);
};
function checkInvalidScopeReference(node, method, scriptSetup) {
  if (!node)
    return;
  _compilersfc.walkIdentifiers.call(void 0, node, (id) => {
    if (Object.keys(scriptSetup.bindings).includes(id.name) && !Object.keys(scriptSetup.imports).includes(id.name))
      throw new SyntaxError(`\`${method}()\` in <script setup> cannot reference locally declared variables because it will be hoisted outside of the setup() function.`);
  });
}
var hasPropsOrEmits = (node) => node.properties.some((prop) => (prop.type === "ObjectProperty" || prop.type === "ObjectMethod") && prop.key.type === "Identifier" && (prop.key.name === "props" || prop.key.name === "emits"));







exports.isCallOf = isCallOf; exports.parseSFC = parseSFC; exports.filterMarco = filterMarco; exports.checkInvalidScopeReference = checkInvalidScopeReference; exports.hasPropsOrEmits = hasPropsOrEmits;
